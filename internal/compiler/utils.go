package compiler

import (
	"fmt"
	"github.com/Kolterdyx/mcbasic/internal/ast"
	"github.com/Kolterdyx/mcbasic/internal/interfaces"
	"github.com/Kolterdyx/mcbasic/internal/ir"
	"github.com/Kolterdyx/mcbasic/internal/paths"

	"github.com/Kolterdyx/mcbasic/internal/tokens"
	"github.com/Kolterdyx/mcbasic/internal/types"
	log "github.com/sirupsen/logrus"
	"path"
	"strings"
)

func (c *Compiler) structPath(path string) string {
	return fmt.Sprintf("%s.%s", StructPath, path)
}

func (c *Compiler) makeReg(reg string) string {
	c.registerCounter++
	return fmt.Sprintf("%s%d", reg, c.registerCounter)
}

func (c *Compiler) macroLineIdentifier(source string) string {
	lines := strings.Split(source, "\n")
	if len(lines) == 0 {
		return ""
	}
	for i, line := range lines {
		if strings.Contains(line, "$(") && !strings.HasPrefix(line, "$") {
			lines[i] = "$" + line
		}
	}
	return strings.Join(lines, "\n")
}

func (c *Compiler) getFuncPath(namespace string) string {
	return path.Join(c.DatapackRoot, paths.Data, namespace, paths.Functions)
}

func (c *Compiler) makeBranchFunction(branchName string, body ast.BlockStmt) interfaces.Function {

	// If the body contains a return statement, add a statement before to set the RETF flag

	newBody := ast.BlockStmt{}

	for _, stmt := range body.Statements {
		if stmt.Type() == ast.ReturnStatement {
			// Insert a statement to set the RETF flag
			newBody.Statements = append(newBody.Statements, ast.SetReturnFlagStmt{})
		}
		newBody.Statements = append(newBody.Statements, stmt)
	}

	source := ast.AcceptStmt[interfaces.IRCode](ast.FunctionDeclarationExpr{
		Name: &tokens.Token{
			Type:   tokens.Identifier,
			Lexeme: branchName,
		},
		Body:          newBody,
		ReturnType:    types.VoidType,
		Autogenerated: true,
	}, c)

	return ir.NewFunction(branchName, source)
}

func (c *Compiler) error(location ast.Node, message string) {
	log.Errorf("[Position %s] ExceptionString: %s\n", location.GetSourceLocation().ToString(), message)
}

func (c *Compiler) varPath(path string) string {
	if path == RET {
		return fmt.Sprintf("%s.%s", VarPath, RET)
	}
	if strings.HasPrefix(path, fmt.Sprintf("%s.", VarPath)) {
		return path
	}
	return fmt.Sprintf("%s.%s.$(__call__)", VarPath, path)
}
