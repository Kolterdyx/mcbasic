package compiler

import (
	"fmt"
	"github.com/Kolterdyx/mcbasic/internal/interfaces"
	"github.com/Kolterdyx/mcbasic/internal/ir"
	"github.com/Kolterdyx/mcbasic/internal/paths"
	"github.com/Kolterdyx/mcbasic/internal/statements"
	"github.com/Kolterdyx/mcbasic/internal/tokens"
	"github.com/Kolterdyx/mcbasic/internal/types"
	log "github.com/sirupsen/logrus"
	"path"
	"strings"
)

func (c *Compiler) structPath(path string) string {
	return fmt.Sprintf("%s.%s", StructPath, path)
}

func (c *Compiler) makeReg(reg string) string {
	c.registerCounter++
	return fmt.Sprintf("%s%d", reg, c.registerCounter)
}

// Searches the current scopes for functionDefinitions and variables, returns the type of the variable or function
func (c *Compiler) getReturnType(name string) types.ValueType {
	for _, identifier := range c.scopes[c.currentScope] {
		if identifier.Name == name {
			return identifier.Type
		}
	}
	return types.VoidType
}

func (c *Compiler) macroLineIdentifier(source string) string {
	lines := strings.Split(source, "\n")
	if len(lines) == 0 {
		return ""
	}
	for i, line := range lines {
		if strings.Contains(line, "$(") && !(line[0:1] == "$") {
			lines[i] = "$" + line
		}
	}
	return strings.Join(lines, "\n")
}

func (c *Compiler) getFuncPath(namespace string) string {
	return path.Join(c.DatapackRoot, paths.Data, namespace, paths.Functions)
}

func (c *Compiler) makeBranchFunction(branchName string, body statements.BlockStmt) interfaces.Function {

	// If the body contains a return statement, add a statement before to set the RETF flag

	newBody := statements.BlockStmt{}

	for _, stmt := range body.Statements {
		if stmt.StmtType() == statements.ReturnStmtType {
			// Insert a statement to set the RETF flag
			newBody.Statements = append(newBody.Statements, statements.SetReturnFlagStmt{})
		}
		newBody.Statements = append(newBody.Statements, stmt)
	}

	source := statements.FunctionDeclarationStmt{
		Name: tokens.Token{
			Type:   tokens.Identifier,
			Lexeme: branchName,
		},
		Body:          newBody,
		Autogenerated: true,
	}.Accept(c)

	return ir.NewFunction(branchName, source)
}

func (c *Compiler) error(location interfaces.SourceLocation, message string) {
	log.Errorf("[Position %s] Exception: %s\n", location.ToString(), message)
}

func (c *Compiler) varPath(path string) string {
	if path == RET {
		return fmt.Sprintf("%s.%s", VarPath, RET)
	}
	if strings.HasPrefix(path, fmt.Sprintf("%s.", VarPath)) {
		return path
	}
	return fmt.Sprintf("%s.%s.$(__call__)", VarPath, path)
}
