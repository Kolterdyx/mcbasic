package compiler

import (
	"fmt"
	"github.com/Kolterdyx/mcbasic/internal/ast"
	"github.com/Kolterdyx/mcbasic/internal/interfaces"
	"github.com/Kolterdyx/mcbasic/internal/ir"
	"github.com/Kolterdyx/mcbasic/internal/nbt"
	"github.com/Kolterdyx/mcbasic/internal/paths"

	"github.com/Kolterdyx/mcbasic/internal/types"
	"github.com/Kolterdyx/mcbasic/internal/utils"
	"path"
)

func (c *Compiler) VisitExpression(stmt ast.ExpressionStmt) any {
	return stmt.Expression.Accept(c)
}

func (c *Compiler) VisitVariableDeclaration(stmt ast.VariableDeclarationStmt) any {
	cmd := c.n()
	if stmt.Initializer != nil {
		cmd.Extend(ast.AcceptExpr[interfaces.IRCode](stmt.Initializer, c))
		cmd.CopyVar(RX, stmt.Name.Lexeme)
	} else {
		cmd = cmd.SetVar(stmt.Name.Lexeme, stmt.ValueType.ToNBT())
	}
	return cmd
}

func (c *Compiler) VisitFunctionDeclaration(stmt ast.FunctionDeclarationStmt) any {
	cmd := c.n()

	wrapperArgMacroCompound := nbt.NewCompound()

	if !stmt.Autogenerated {
		c.currentScope = stmt.Name.Lexeme
		c.branchCounter = 0
		c.scopes[c.currentScope] = make([]interfaces.TypedIdentifier, 0)

		_, fn := utils.SplitFunctionName(c.currentScope, c.Namespace)

		f := interfaces.FunctionDefinition{
			Name:       fn,
			Args:       make([]interfaces.TypedIdentifier, 0),
			ReturnType: stmt.ReturnType,
		}
		for _, parameter := range stmt.Parameters {
			f.Args = append(f.Args, interfaces.TypedIdentifier{Name: parameter.Name.Lexeme, Type: parameter.ValueType})
		}
		f.Args = append(f.Args, interfaces.TypedIdentifier{Name: "__call__", Type: types.IntType})
		c.functionDefinitions[c.currentScope] = f

		// For each parameter, copy the value to a variable with the same name and add it to the scope
		for _, arg := range stmt.Parameters {
			macro := fmt.Sprintf("$(%s)", arg.Name)
			if arg.ValueType.Equals(types.StringType) {
				wrapperArgMacroCompound.Set(arg.Name.Lexeme, nbt.NewString(macro))
				cmd.Set(c.varPath(arg.Name.Lexeme), nbt.NewString(macro))
			} else {
				wrapperArgMacroCompound.Set(arg.Name.Lexeme, nbt.NewAny(macro))
				cmd.Set(c.varPath(arg.Name.Lexeme), nbt.NewAny(macro))
			}
			c.scopes[c.currentScope] = append(c.scopes[c.currentScope],
				interfaces.TypedIdentifier{
					Name: arg.Name.Lexeme,
					Type: arg.ValueType,
				})
		}

		// add function to all scopes
		for scope := range c.scopes {
			c.scopes[scope] = append(c.scopes[scope],
				interfaces.TypedIdentifier{
					Name: stmt.Name.Lexeme,
					Type: stmt.ReturnType,
				})
		}

	}

	cmd.Extend(ast.AcceptStmt[interfaces.IRCode](stmt.Body, c))
	cmd.Ret()

	if !stmt.Autogenerated {
		// Wrapper that calls the function with the correct arguments
		funcName := path.Join(paths.FunctionBranches, c.currentScope)
		c.compiledFunctions[funcName] = ir.NewFunction(funcName, cmd)
		wrapper := c.n()
		if wrapperArgMacroCompound.Size() > 0 {
			wrapper.SetArgs(c.currentScope, wrapperArgMacroCompound)
		}
		wrapper.
			CallWithArgs(funcName, fmt.Sprintf("%s.%s", ArgPath, c.currentScope)).
			Ret()
		c.compiledFunctions[stmt.Name.Lexeme] = ir.NewFunction(c.currentScope, wrapper)
		return wrapper
	}
	return cmd
}

func (c *Compiler) VisitVariableAssignment(stmt ast.VariableAssignmentStmt) any {
	cmd := c.n()
	isIndexedAssignment := len(stmt.Accessors) > 0
	if !stmt.Value.ReturnType().Equals(c.getReturnType(stmt.Name.Lexeme)) && !isIndexedAssignment {
		c.error(stmt.Name.SourceLocation, fmt.Sprintf("Assignment type mismatch: %v != %v", c.getReturnType(stmt.Name.Lexeme).ToString(), stmt.Value.ReturnType().ToString()))
	}
	valueReg := c.makeReg(RX)
	cmd.Extend(ast.AcceptExpr[interfaces.IRCode](stmt.Value, c))
	cmd.CopyVar(RX, valueReg)
	pathReg := c.makeReg(RX)
	cmd.SetVar(pathReg, nbt.NewString(""))
	if isIndexedAssignment {
		for _, accessor := range stmt.Accessors {
			switch accessor := accessor.(type) {
			case ast.IndexAccessor:
				cmd.Extend(ast.AcceptExpr[interfaces.IRCode](accessor.Index, c))
				cmd.MakeIndex(RX, RX)
				cmd.StringConcat(pathReg, RX, pathReg)
			case ast.FieldAccessor:
				fieldReg := c.makeReg(RX)
				cmd.Set(fieldReg, nbt.NewString(accessor.ToString()))
				cmd.StringConcat(pathReg, fieldReg, pathReg)
			}
		}
	}
	cmd.PathSet(stmt.Name.Lexeme, pathReg, valueReg)
	return cmd
}

func (c *Compiler) VisitStructDeclaration(stmt ast.StructDeclarationStmt) any {
	cmd := c.n()
	return cmd.Set(c.structPath(stmt.Name.Lexeme), stmt.StructType.ToNBT())
}

func (c *Compiler) VisitBlock(stmt ast.BlockStmt) any {
	cmd := c.n()
	for _, statement := range stmt.Statements {
		cmd.Extend(ast.AcceptStmt[interfaces.IRCode](statement, c))
	}
	return cmd
}

func (c *Compiler) VisitWhile(stmt ast.WhileStmt) any {
	//TODO implement me
	panic("implement me")
}

func (c *Compiler) VisitIf(stmt ast.IfStmt) any {
	cmd := c.n()

	c.branchCounter++
	thenBranchName := path.Join(paths.FunctionBranches, fmt.Sprintf("%s_%d_if", c.currentScope, c.branchCounter))
	elseBranchName := path.Join(paths.FunctionBranches, fmt.Sprintf("%s_%d_else", c.currentScope, c.branchCounter))

	cmd.Score(RETF, nbt.NewInt(0))
	c.compiledFunctions[thenBranchName] = c.makeBranchFunction(thenBranchName, stmt.ThenBranch)

	hasElseBranch := stmt.ElseBranch != nil
	if hasElseBranch {
		c.compiledFunctions[elseBranchName] = c.makeBranchFunction(elseBranchName, *stmt.ElseBranch)
	}
	cmd.Extend(ast.AcceptExpr[interfaces.IRCode](stmt.Condition, c))
	condVar := c.makeReg(RX)
	cmd.CopyVar(RX, condVar)
	cmd.Load(condVar, condVar)
	cmd.If(condVar, c.n().Branch(thenBranchName, c.currentScope))
	cmd.If(RETF, c.n().Ret())
	if hasElseBranch {
		cmd.Unless(condVar, c.n().Branch(elseBranchName, c.currentScope))
		cmd.If(RETF, c.n().Ret())
	}
	return cmd
}

func (c *Compiler) VisitReturn(stmt ast.ReturnStmt) any {
	cmd := c.n()
	if stmt.Expression != nil {
		cmd.Extend(ast.AcceptExpr[interfaces.IRCode](stmt.Expression, c))
		cmd.CopyVar(RX, RET)
	}
	cmd.Ret()
	return cmd
}

func (c *Compiler) VisitSetReturnFlag(stmt ast.SetReturnFlagStmt) any {
	return c.n().Score(RETF, nbt.NewInt(1))
}
