package compiler

import (
	"fmt"
	"github.com/Kolterdyx/mcbasic/internal/ast"
	"github.com/Kolterdyx/mcbasic/internal/interfaces"
	"github.com/Kolterdyx/mcbasic/internal/ir"
	"github.com/Kolterdyx/mcbasic/internal/nbt"
	"github.com/Kolterdyx/mcbasic/internal/paths"
	"github.com/Kolterdyx/mcbasic/internal/types"
	"github.com/Kolterdyx/mcbasic/internal/utils"
	"path"
)

func (c *Compiler) VisitExpression(stmt ast.ExpressionStmt) any {
	return stmt.Expression.Accept(c)
}

func (c *Compiler) VisitVariableDeclaration(stmt ast.VariableDeclarationStmt) any {
	cmd := c.n()
	if stmt.Initializer != nil {
		cmd.Extend(ast.AcceptExpr[interfaces.IRCode](stmt.Initializer, c))
		cmd.CopyVar(RX, stmt.Name.Lexeme)
	} else {
		cmd = cmd.SetVar(stmt.Name.Lexeme, stmt.ValueType.ToNBT())
	}
	return cmd
}

func (c *Compiler) VisitFunctionDeclaration(stmt ast.FunctionDeclarationStmt) any {
	cmd := c.n()

	wrapperArgMacroCompound := nbt.NewCompound()

	if !stmt.Autogenerated {
		c.branchCounter = 0
		newScope, ok := c.currentScope.GetChild(stmt.Name.Lexeme)
		if !ok {
			c.error(stmt, fmt.Sprintf("Function %s is not defined", stmt.Name.Lexeme))
		}
		c.currentScope = newScope
		defer func() {
			c.currentScope = c.currentScope.GetParent()
		}()

		// For each parameter, copy the value to a variable with the same name and add it to the scope
		for _, arg := range stmt.Parameters {
			macro := fmt.Sprintf("$(%s)", arg.Name)
			if arg.ValueType.Equals(types.StringType) {
				wrapperArgMacroCompound.Set(arg.Name.Lexeme, nbt.NewString(macro))
				cmd.Set(c.varPath(arg.Name.Lexeme), nbt.NewString(macro))
			} else {
				wrapperArgMacroCompound.Set(arg.Name.Lexeme, nbt.NewAny(macro))
				cmd.Set(c.varPath(arg.Name.Lexeme), nbt.NewAny(macro))
			}
		}
	}

	cmd.Extend(ast.AcceptStmt[interfaces.IRCode](stmt.Body, c))
	cmd.Ret()

	if !stmt.Autogenerated {
		// Wrapper that calls the function with the correct arguments
		funcName := c.currentScope.ScopeName()
		funcFile := path.Join(paths.FunctionBranches, utils.FileSpecifier(stmt.GetSourceLocation().File, funcName))
		wrapperFuncFile := utils.FileSpecifier(stmt.GetSourceLocation().File, funcName)

		c.compiledFunctions[funcFile] = ir.NewFunction(funcFile, cmd)
		wrapper := c.n()
		if wrapperArgMacroCompound.Size() > 0 {
			wrapper.SetArgs(funcFile, wrapperArgMacroCompound)
		}
		wrapper.
			CallWithArgs(funcFile, fmt.Sprintf("%s.%s", ArgPath, funcFile)).
			Ret()
		c.compiledFunctions[wrapperFuncFile] = ir.NewFunction(wrapperFuncFile, wrapper)
		return wrapper
	}
	return cmd
}

func (c *Compiler) VisitVariableAssignment(stmt ast.VariableAssignmentStmt) any {
	cmd := c.n()
	isIndexedAssignment := len(stmt.Accessors) > 0
	valueReg := c.makeReg(RX)
	cmd.Extend(ast.AcceptExpr[interfaces.IRCode](stmt.Value, c))
	cmd.CopyVar(RX, valueReg)
	pathReg := c.makeReg(RX)
	cmd.SetVar(pathReg, nbt.NewString(""))
	if isIndexedAssignment {
		for _, accessor := range stmt.Accessors {
			switch accessor := accessor.(type) {
			case ast.IndexAccessor:
				cmd.Extend(ast.AcceptExpr[interfaces.IRCode](accessor.Index, c))
				cmd.MakeIndex(RX, RX)
				cmd.StringConcat(pathReg, RX, pathReg)
			case ast.FieldAccessor:
				fieldReg := c.makeReg(RX)
				cmd.Set(fieldReg, nbt.NewString(accessor.ToString()))
				cmd.StringConcat(pathReg, fieldReg, pathReg)
			}
		}
	}
	cmd.PathSet(stmt.Name.Lexeme, pathReg, valueReg)
	return cmd
}

func (c *Compiler) VisitStructDeclaration(stmt ast.StructDeclarationStmt) any {
	cmd := c.n()
	return cmd.Set(c.structPath(stmt.Name.Lexeme), stmt.StructType.ToNBT())
}

func (c *Compiler) VisitBlock(stmt ast.BlockStmt) any {
	cmd := c.n()
	for _, statement := range stmt.Statements {
		cmd.Extend(ast.AcceptStmt[interfaces.IRCode](statement, c))
	}
	return cmd
}

func (c *Compiler) VisitWhile(_ ast.WhileStmt) any {
	//TODO implement me
	panic("implement me")
}

func (c *Compiler) VisitIf(stmt ast.IfStmt) any {
	cmd := c.n()

	c.branchCounter++
	thenBranchName := path.Join(paths.FunctionBranches, utils.FileSpecifier(c.currentScope.ScopeName(), fmt.Sprintf("%s_%d_if", c.currentScope.ScopeName(), c.branchCounter)))
	elseBranchName := path.Join(paths.FunctionBranches, utils.FileSpecifier(c.currentScope.ScopeName(), fmt.Sprintf("%s_%d_else", c.currentScope.ScopeName(), c.branchCounter)))

	cmd.Score(RETF, nbt.NewInt(0))
	c.compiledFunctions[thenBranchName] = c.makeBranchFunction(thenBranchName, stmt.ThenBranch)

	hasElseBranch := stmt.ElseBranch != nil
	if hasElseBranch {
		c.compiledFunctions[elseBranchName] = c.makeBranchFunction(elseBranchName, *stmt.ElseBranch)
	}
	cmd.Extend(ast.AcceptExpr[interfaces.IRCode](stmt.Condition, c))
	condVar := c.makeReg(RX)
	cmd.CopyVar(RX, condVar)
	cmd.Load(condVar, condVar)
	cmd.If(condVar, c.n().Branch(thenBranchName, c.currentScope.ScopeName()))
	cmd.If(RETF, c.n().Ret())
	if hasElseBranch {
		cmd.Unless(condVar, c.n().Branch(elseBranchName, c.currentScope.ScopeName()))
		cmd.If(RETF, c.n().Ret())
	}
	return cmd
}

func (c *Compiler) VisitReturn(stmt ast.ReturnStmt) any {
	cmd := c.n()
	if stmt.Expression != nil {
		cmd.Extend(ast.AcceptExpr[interfaces.IRCode](stmt.Expression, c))
		cmd.CopyVar(RX, RET)
	}
	cmd.Ret()
	return cmd
}

func (c *Compiler) VisitSetReturnFlag(_ ast.SetReturnFlagStmt) any {
	return c.n().Score(RETF, nbt.NewInt(1))
}

func (c *Compiler) VisitImport(_ ast.ImportStmt) any {
	//TODO implement me
	panic("implement me")
}

func (c *Compiler) VisitExec(stmt ast.ExecStmt) any {
	cmd := c.n()
	cmd.Extend(ast.AcceptExpr[interfaces.IRCode](stmt.Expression, c))
	cmd.ExecReg(RX)
	return cmd
}
