package compiler

import (
	"fmt"
	"github.com/Kolterdyx/mcbasic/internal/interfaces"
	"github.com/Kolterdyx/mcbasic/internal/ir"
	"github.com/Kolterdyx/mcbasic/internal/nbt"
	"github.com/Kolterdyx/mcbasic/internal/paths"
	"github.com/Kolterdyx/mcbasic/internal/statements"
	"github.com/Kolterdyx/mcbasic/internal/types"
	"github.com/Kolterdyx/mcbasic/internal/utils"
	"path"
)

func (c *Compiler) VisitExpression(stmt statements.ExpressionStmt) interfaces.IRCode {
	return stmt.Expression.Accept(c)
}

func (c *Compiler) VisitVariableDeclaration(stmt statements.VariableDeclarationStmt) interfaces.IRCode {
	cmd := c.n()
	if stmt.Initializer != nil {
		cmd.Extend(stmt.Initializer.Accept(c))
		cmd.CopyVar(RX, stmt.Name.Lexeme)
	} else {
		cmd = cmd.SetVar(stmt.Name.Lexeme, stmt.Type.ToNBT())
	}
	return cmd
}

func (c *Compiler) VisitFunctionDeclaration(stmt statements.FunctionDeclarationStmt) interfaces.IRCode {
	cmd := c.n()

	if !stmt.Autogenerated {
		c.currentScope = stmt.Name.Lexeme
		c.branchCounter = 0
		c.scopes[c.currentScope] = make([]interfaces.TypedIdentifier, 0)

		_, fn := utils.SplitFunctionName(c.currentScope, c.Namespace)

		f := interfaces.FunctionDefinition{
			Name:       fn,
			Args:       make([]interfaces.TypedIdentifier, 0),
			ReturnType: stmt.ReturnType,
		}
		for _, parameter := range stmt.Parameters {
			f.Args = append(f.Args, interfaces.TypedIdentifier{Name: parameter.Name, Type: parameter.Type})
		}
		f.Args = append(f.Args, interfaces.TypedIdentifier{Name: "__call__", Type: types.IntType})
		c.functionDefinitions[c.currentScope] = f

		// For each parameter, copy the value to a variable with the same name and add it to the scope
		for _, arg := range stmt.Parameters {
			macro := fmt.Sprintf("$(%s)", arg.Name)
			if arg.Type.Equals(types.StringType) {
				cmd.Set(c.varPath(arg.Name), nbt.NewString(macro))
			} else {
				cmd.Set(c.varPath(arg.Name), nbt.NewAny(macro))
			}
			c.scopes[c.currentScope] = append(c.scopes[c.currentScope],
				interfaces.TypedIdentifier{
					Name: arg.Name,
					Type: arg.Type,
				})
		}

		// add function to all scopes
		for scope := range c.scopes {
			c.scopes[scope] = append(c.scopes[scope],
				interfaces.TypedIdentifier{
					Name: stmt.Name.Lexeme,
					Type: stmt.ReturnType,
				})
		}

	}

	cmd.Extend(stmt.Body.Accept(c))
	cmd.Ret()

	if !stmt.Autogenerated {
		// Wrapper that calls the function with the correct arguments
		funcName := path.Join(paths.FunctionBranches, c.currentScope)
		c.compiledFunctions[funcName] = ir.NewFunction(funcName, cmd)
		wrapper := c.n()
		wrapper.Branch(funcName, c.currentScope)
		wrapper.Ret()
		c.compiledFunctions[stmt.Name.Lexeme] = ir.NewFunction(c.currentScope, wrapper)
		return wrapper
	}
	return cmd
}

func (c *Compiler) VisitVariableAssignment(stmt statements.VariableAssignmentStmt) interfaces.IRCode {
	cmd := c.n()
	isIndexedAssignment := len(stmt.Accessors) > 0
	if !stmt.Value.ReturnType().Equals(c.getReturnType(stmt.Name.Lexeme)) && !isIndexedAssignment {
		c.error(stmt.Name.SourceLocation, fmt.Sprintf("Assignment type mismatch: %v != %v", c.getReturnType(stmt.Name.Lexeme).ToString(), stmt.Value.ReturnType().ToString()))
	}
	valueReg := c.makeReg(RX)
	cmd.Extend(stmt.Value.Accept(c))
	cmd.CopyVar(RX, valueReg)
	pathReg := c.makeReg(RX)
	cmd.SetVar(pathReg, nbt.NewString(""))
	if isIndexedAssignment {
		for _, accessor := range stmt.Accessors {
			switch accessor := accessor.(type) {
			case statements.IndexAccessor:
				cmd.Extend(accessor.Index.Accept(c))
				cmd.MakeIndex(RX, RX)
				cmd.StringConcat(pathReg, RX, pathReg)
			case statements.FieldAccessor:
				fieldReg := c.makeReg(RX)
				cmd.Set(fieldReg, nbt.NewString(accessor.ToString()))
				cmd.StringConcat(pathReg, fieldReg, pathReg)
			}
		}
	}
	cmd.PathSet(stmt.Name.Lexeme, pathReg, valueReg)
	return cmd
}

func (c *Compiler) VisitStructDeclaration(stmt statements.StructDeclarationStmt) interfaces.IRCode {
	cmd := c.n()
	return cmd.Set(c.structPath(stmt.Name.Lexeme), stmt.StructType.ToNBT())
}

func (c *Compiler) VisitBlock(stmt statements.BlockStmt) interfaces.IRCode {
	cmd := c.n()
	for _, statement := range stmt.Statements {
		cmd.Extend(statement.Accept(c))
	}
	return cmd
}

func (c *Compiler) VisitWhile(stmt statements.WhileStmt) interfaces.IRCode {
	//TODO implement me
	panic("implement me")
}

func (c *Compiler) VisitIf(stmt statements.IfStmt) interfaces.IRCode {
	cmd := c.n()

	c.branchCounter++
	thenBranchName := path.Join(paths.FunctionBranches, fmt.Sprintf("%s_%d_if", c.currentScope, c.branchCounter))
	elseBranchName := path.Join(paths.FunctionBranches, fmt.Sprintf("%s_%d_else", c.currentScope, c.branchCounter))

	cmd.Score(RETF, nbt.NewInt(0))
	c.compiledFunctions[thenBranchName] = c.makeBranchFunction(thenBranchName, stmt.ThenBranch)

	hasElseBranch := stmt.ElseBranch != nil
	if hasElseBranch {
		c.compiledFunctions[elseBranchName] = c.makeBranchFunction(elseBranchName, *stmt.ElseBranch)
	}
	cmd.Extend(stmt.Condition.Accept(c))
	condVar := c.makeReg(RX)
	cmd.CopyVar(RX, condVar)
	cmd.Load(condVar, condVar)
	cmd.If(condVar, c.n().Branch(thenBranchName, c.currentScope))
	cmd.If(RETF, c.n().Ret())
	if hasElseBranch {
		cmd.Unless(condVar, c.n().Branch(elseBranchName, c.currentScope))
		cmd.If(RETF, c.n().Ret())
	}
	return cmd
}

func (c *Compiler) VisitReturn(stmt statements.ReturnStmt) interfaces.IRCode {
	cmd := c.n()
	if stmt.Expression != nil {
		cmd.Extend(stmt.Expression.Accept(c))
		cmd.CopyVar(RX, RET)
	}
	cmd.Ret()
	return cmd
}

func (c *Compiler) VisitScore(stmt statements.ScoreStmt) interfaces.IRCode {
	return c.n().Score(stmt.Target, nbt.NewInt(stmt.Score))
}

func (c *Compiler) VisitSetReturnFlag(stmt statements.SetReturnFlagStmt) interfaces.IRCode {
	return c.n().Score(RETF, nbt.NewInt(1))
}
