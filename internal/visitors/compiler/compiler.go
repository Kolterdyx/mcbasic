package compiler

import (
	"fmt"
	"github.com/Kolterdyx/mcbasic/internal"
	"github.com/Kolterdyx/mcbasic/internal/expressions"
	"github.com/Kolterdyx/mcbasic/internal/interfaces"
	"github.com/Kolterdyx/mcbasic/internal/parser"
	"github.com/Kolterdyx/mcbasic/internal/statements"
	"github.com/Kolterdyx/mcbasic/internal/tokens"
	"github.com/Kolterdyx/mcbasic/internal/visitors/compiler/ops"
	cp "github.com/otiai10/copy"
	log "github.com/sirupsen/logrus"
	"os"
	"path/filepath"
	"strconv"
)

type Func struct {
	Name string
	Args []statements.FuncArg
}

type Compiler struct {
	Config       interfaces.ProjectConfig
	Namespace    string
	DatapackRoot string

	functionsPath string
	tagsPath      string

	currentFunction statements.FunctionDeclarationStmt
	currentScope    string

	functions map[string]Func

	scope map[string][]string

	opHandler ops.Op

	expressions.ExprVisitor
	statements.StmtVisitor

	regCounter int

	InitFuncName string
	TickFuncName string
}

func NewCompiler(config interfaces.ProjectConfig) *Compiler {
	c := &Compiler{Config: config, InitFuncName: "mcb/init", TickFuncName: "mcb/tick"}
	c.Namespace = config.Project.Namespace
	c.opHandler = ops.Op{Namespace: c.Namespace}
	c.functions = make(map[string]Func)
	c.scope = make(map[string][]string)

	return c
}

func (c *Compiler) Compile(program parser.Program) {
	err := c.createDirectoryTree()
	if err != nil {
		log.Fatalln(err)
	}
	c.createPackMeta()
	for _, function := range program.Functions {
		f := Func{
			Name: function.Name.Lexeme,
			Args: make([]statements.FuncArg, 0),
		}
		for _, parameter := range function.Parameters {
			f.Args = append(f.Args, statements.FuncArg{
				Name: parameter.Name,
				Type: parameter.Type,
			})
		}
		f.Args = append(f.Args, statements.FuncArg{
			Name: "__call__",
			Type: tokens.NumberType,
		})
		c.functions[function.Name.Lexeme] = f
	}

	// Built-in functions are protected by the compiler, so they can't be overwritten
	c.createFunctionTags()
	c.createBuiltinFunctions()

	// Traverse the AST to generate the functions
	for _, f := range program.Functions {
		f.Accept(c)
	}
	err = cp.Copy(c.DatapackRoot, "/home/kolterdyx/.minecraft/saves/Test/datapacks/"+c.Config.Project.Name)
	if err != nil {
		log.Fatalln(err)
	}
}

func (c *Compiler) createDirectoryTree() error {
	c.Namespace = c.Config.Project.Namespace
	c.DatapackRoot, _ = filepath.Abs(c.Config.Project.Name)
	log.Infof("Compiling to %s\n", c.DatapackRoot)
	c.functionsPath = c.DatapackRoot + "/data/" + c.Namespace + "/functions"
	c.tagsPath = c.DatapackRoot + "/data/minecraft/tags"

	err := os.MkdirAll(c.functionsPath, 0755)
	err = os.MkdirAll(c.tagsPath, 0755)
	err = os.MkdirAll(c.functionsPath+"/builtin", 0755)
	return err
}

func (c *Compiler) createPackMeta() {
	packMcmeta := `{
	"pack": {
		"description": "Generated by mcbasic",
		"pack_format": 26
	}
}`
	err := os.WriteFile(c.DatapackRoot+"/pack.mcmeta", []byte(packMcmeta), 0644)
	if err != nil {
		log.Fatalln(err)
	}
}

func (c *Compiler) createBuiltinFunctions() {
	c.createFunction(
		"print",
		`$tellraw @a {"text":"$(text)"}`,
		[]statements.FuncArg{
			{Name: "text", Type: tokens.StringType},
		},
	)
	c.createFunction(
		"exec",
		`$execute run $(command)`,
		[]statements.FuncArg{
			{Name: "command", Type: tokens.StringType},
		},
	)
	c.createFunction(
		"builtin/init",
		fmt.Sprintf("scoreboard objectives add %s dummy\n", c.Namespace)+
			c.opHandler.RegLoad(strconv.Itoa(internal.FixedPointMagnitude), ops.RCF)+
			c.opHandler.RegLoad("0", ops.CALL)+
			c.opHandler.Set("tmp", "MCB pack loaded")+
			c.opHandler.ArgLoad("print", "text", "tmp")+
			c.opHandler.Call("main"),
		[]statements.FuncArg{},
	)
}

func (c *Compiler) createFunction(name string, source string, args []statements.FuncArg) {
	filename := name + ".mcfunction"

	if name == c.InitFuncName || name == c.TickFuncName {
		return
	}
	f := Func{
		Name: name,
		Args: make([]statements.FuncArg, 0),
	}
	for _, parameter := range args {
		f.Args = append(f.Args, statements.FuncArg{Name: parameter.Name, Type: parameter.Type})
	}
	f.Args = append(f.Args, statements.FuncArg{Name: "__call__", Type: tokens.NumberType})
	c.functions[name] = f

	err := os.WriteFile(c.functionsPath+"/"+filename, []byte(source), 0644)
	if err != nil {
		log.Fatalln(err)
	}
}

func (c *Compiler) createFunctionTags() {
	// load tag
	loadTag := `{
	"values": [
		"%s"
	]
}`
	err := os.MkdirAll(c.tagsPath+"/functions", 0755)
	if err != nil {
		log.Fatalln(err)
	}
	err = os.WriteFile(c.tagsPath+"/functions/load.json", []byte(fmt.Sprintf(loadTag, c.Namespace+":builtin/init")), 0644)
	if err != nil {
		log.Fatalln(err)
	}
}

func (c *Compiler) error(location interfaces.SourceLocation, message string) {
	log.Fatalf("Error at %d:%d: %s\n", location.Line+1, location.Column, message)
}

func (c *Compiler) newRegister(regName string) string {
	c.regCounter++
	return regName + fmt.Sprintf("%d_", c.regCounter)
}
